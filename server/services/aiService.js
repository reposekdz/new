
const { GoogleGenAI, Type } = require("@google/genai");
const { getSystemInstruction, getExecutionSystemInstruction } = require('../utils/prompts');

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const MAX_OUTPUT_TOKENS = 8192;
const MAX_RETRIES = 2;

// --- HELPER: COMPLEXITY ANALYSIS ---
const analyzeComplexity = (prompt) => {
    const complexKeywords = ['architecture', 'backend', 'database', 'auth', 'realtime', 'socket', 'dashboard', 'cms', 'saas', 'enterprise'];
    const score = complexKeywords.reduce((acc, kw) => prompt.toLowerCase().includes(kw) ? acc + 1 : acc, 0);
    return score > 0;
};

// --- HELPER: ADAPTIVE THINKING BUDGET ---
const getAdaptiveThinkingBudget = (model, prompt) => {
    if (!model.includes('flash')) return 0; 
    const isComplex = analyzeComplexity(prompt);
    return isComplex ? 8000 : 1024; 
};

// --- HELPER: ADVANCED SCAFFOLDING ---
const setupProject = (files, projectName = 'omnigen-project') => {
  const newFiles = [...files];
  const filePaths = new Set(newFiles.map(f => f.path));

  // 1. Detect Tech Stack
  const isPython = newFiles.some(f => f.path.endsWith('.py'));
  const isRust = newFiles.some(f => f.path.endsWith('.rs'));
  const isNode = newFiles.some(f => f.path.endsWith('.js') || f.path.endsWith('.ts') || f.path.endsWith('.jsx') || f.path.endsWith('.tsx'));
  const isTypescript = newFiles.some(f => f.path.endsWith('.ts') || f.path.endsWith('.tsx'));
  const isReact = newFiles.some(f => f.content.includes('react') || f.path.includes('.tsx') || f.path.includes('.jsx'));

  // 2. Generate .gitignore
  if (!filePaths.has('.gitignore')) {
    let content = "node_modules/\n.env\n.DS_Store\ndist/\nbuild/\n.vscode/\ncoverage/";
    if (isPython) content += "\n__pycache__/\n*.pyc\nvenv/\n.pytest_cache/";
    if (isRust) content += "\ntarget/\nCargo.lock";
    newFiles.push({ path: '.gitignore', content });
  }

  // 3. Generate package.json (Node/React)
  if (!filePaths.has('package.json') && isNode) {
    const pkg = {
      name: projectName,
      version: "1.0.0",
      description: "Generated by OmniGen AI",
      main: isTypescript ? "src/main.tsx" : "src/index.jsx",
      type: "module",
      scripts: {
        "start": "vite",
        "build": isTypescript ? "tsc && vite build" : "vite build",
        "preview": "vite preview",
        "lint": "eslint ."
      },
      dependencies: {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "lucide-react": "^0.344.0",
        "clsx": "^2.1.0",
        "tailwind-merge": "^2.2.1",
        "framer-motion": "^11.0.8"
      },
      devDependencies: {
        "@vitejs/plugin-react": "^4.2.1",
        "autoprefixer": "^10.4.18",
        "postcss": "^8.4.35",
        "tailwindcss": "^3.4.1",
        "vite": "^5.1.4"
      }
    };
    
    if (isTypescript) {
        pkg.devDependencies["typescript"] = "^5.2.2";
        pkg.devDependencies["@types/react"] = "^18.2.66";
        pkg.devDependencies["@types/react-dom"] = "^18.2.22";
    }
    
    newFiles.push({ path: 'package.json', content: JSON.stringify(pkg, null, 2) });
  }

  // 4. Inject tsconfig.json
  if (isTypescript && !filePaths.has('tsconfig.json')) {
      newFiles.push({
          path: 'tsconfig.json',
          content: JSON.stringify({
            "compilerOptions": {
                "target": "ES2020",
                "useDefineForClassFields": true,
                "lib": ["ES2020", "DOM", "DOM.Iterable"],
                "module": "ESNext",
                "skipLibCheck": true,
                "moduleResolution": "bundler",
                "allowImportingTsExtensions": true,
                "resolveJsonModule": true,
                "isolatedModules": true,
                "noEmit": true,
                "jsx": "react-jsx",
                "strict": true,
                "noUnusedLocals": true,
                "noUnusedParameters": true,
                "noFallthroughCasesInSwitch": true
            },
            "include": ["src"],
            "references": [{ "path": "./tsconfig.node.json" }]
          }, null, 2)
      });
      newFiles.push({
          path: 'tsconfig.node.json',
          content: JSON.stringify({
            "compilerOptions": {
                "composite": true,
                "skipLibCheck": true,
                "module": "ESNext",
                "moduleResolution": "bundler",
                "allowSyntheticDefaultImports": true
            },
            "include": ["vite.config.ts"]
          }, null, 2)
      });
  }

  // 5. Inject Tailwind Config
  if (!filePaths.has('tailwind.config.js') && isReact) {
    newFiles.push({
      path: 'tailwind.config.js',
      content: `/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}`
    });
    newFiles.push({
      path: 'postcss.config.js',
      content: `export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}`
    });
  }

  // 6. Ensure Vite Config
  if ((!filePaths.has('vite.config.js') && !filePaths.has('vite.config.ts')) && isReact) {
    newFiles.push({
        path: isTypescript ? 'vite.config.ts' : 'vite.config.js',
        content: `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': '/src',
    },
  },
})`
    });
  }

  // 7. Ensure index.html
  if (isReact && !filePaths.has('index.html')) {
      newFiles.push({
          path: 'index.html',
          content: `<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${projectName}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/${isTypescript ? 'main.tsx' : 'main.jsx'}"></script>
  </body>
</html>`
      });
  }

  return newFiles;
};

const constructPromptParts = (userPrompt, attachments, currentFiles, history) => {
  const parts = [];

  const recentHistory = history.slice(-6); 
  recentHistory.forEach(msg => {
    parts.push({ text: `[PREVIOUS ${msg.role.toUpperCase()} MESSAGE]: ${msg.text}` });
  });

  attachments.forEach((file) => {
    if (file.isImage) {
      const cleanBase64 = file.content.includes(',') ? file.content.split(',')[1] : file.content;
      parts.push({ inlineData: { mimeType: file.type, data: cleanBase64 } });
      parts.push({ text: `\n[REFERENCE IMAGE]: Use this for visual styling.\n` });
    } else {
      parts.push({ text: `\n--- FILE ATTACHMENT: ${file.name} ---\n${file.content}\n--- END ATTACHMENT ---\n` });
    }
  });

  if (currentFiles.length > 0) {
    if (currentFiles.length > 25) {
        const structure = currentFiles.map(f => f.path).join('\n');
        parts.push({ text: `### CURRENT PROJECT STRUCTURE:\n${structure}` });
        const relevantFiles = currentFiles.filter(f => !f.path.endsWith('.svg') && !f.path.endsWith('.json') && f.content.length < 10000);
        const contextStr = relevantFiles.map(f => `// --- FILE: ${f.path} ---\n${f.content}\n`).join('\n');
        parts.push({ text: `### RELEVANT FILE CONTENTS:\n${contextStr}` });
    } else {
        const contextStr = currentFiles.map(f => `// --- FILE: ${f.path} ---\n${f.content}\n`).join('\n');
        parts.push({ text: `### CURRENT PROJECT STATE:\n${contextStr}` });
    }
  }

  const isComplex = analyzeComplexity(userPrompt);
  let augmentedPrompt = userPrompt;
  if (isComplex) {
      augmentedPrompt += "\n[ARCHITECTURAL ADVICE]: This request implies complex logic. Please strictly adhere to Separation of Concerns. Create a dedicated /services folder for business logic, and /types for interfaces.";
  }

  parts.push({
    text: `### USER REQUEST:\n"${augmentedPrompt}"`
  });

  return parts;
};

// --- HELPER: ROBUST JSON PARSING ---
const parseGenAIResponse = (text) => {
  if (!text) return [];
  
  // 1. Basic Cleanup
  let cleanText = text.trim()
    .replace(/^```(?:json)?\s*/, "") // Remove start markdown
    .replace(/\s*```$/, "") // Remove end markdown
    .replace(/^\s*\[\s*json\s*/, "["); // Common hallucination '[ json'

  try {
    const parsed = JSON.parse(cleanText);
    return Array.isArray(parsed) ? parsed : [];
  } catch (e) {
    console.warn("First pass JSON parse failed, attempting aggressive cleanup...");
    
    // 2. Aggressive Cleanup (Fix common LLM trailing commas or markdown in string values)
    try {
        // Try to extract the main array if it's embedded in text
        const arrayMatch = cleanText.match(/\[\s*\{[\s\S]*\}\s*\]/);
        if (arrayMatch) {
            return JSON.parse(arrayMatch[0]);
        }
        throw new Error("No array found");
    } catch (e2) {
        console.error("JSON Parse Error Final:", e.message);
        throw e; // Re-throw to trigger retry logic
    }
  }
};

const mergeFiles = (currentFiles, newFiles) => {
  const fileMap = new Map(currentFiles.map(f => [f.path, f]));
  newFiles.forEach(f => {
    if (f.content === "DELETE") fileMap.delete(f.path);
    else fileMap.set(f.path, f);
  });
  return Array.from(fileMap.values());
};

// --- MAIN GENERATION FUNCTION WITH RETRY ---
const generateApp = async ({ userPrompt, model, attachments = [], currentFiles = [], history = [] }) => {
  const isModification = currentFiles.length > 0;
  const isThinkingModel = model === 'gemini-2.5-flash';
  
  const parts = constructPromptParts(userPrompt, attachments, currentFiles, history);
  const thinkingBudget = getAdaptiveThinkingBudget(model, userPrompt);

  let lastError = null;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
          console.log(`[AI] Generating... Attempt ${attempt}/${MAX_RETRIES}`);
          
          const response = await ai.models.generateContent({
            model: model,
            contents: { parts },
            config: {
              systemInstruction: getSystemInstruction(isModification),
              responseMimeType: "application/json",
              responseSchema: {
                type: Type.ARRAY,
                items: {
                  type: Type.OBJECT,
                  properties: {
                    path: { type: Type.STRING },
                    content: { type: Type.STRING }
                  },
                  required: ["path", "content"]
                }
              },
              maxOutputTokens: MAX_OUTPUT_TOKENS,
              temperature: 0.2 + (attempt * 0.1), // Increase variance on retry
              ...(isThinkingModel ? { thinkingConfig: { thinkingBudget } } : {}),
            }
          });

          let generatedFiles = parseGenAIResponse(response.text);

          if (!isModification && generatedFiles.length > 0) {
              const pkgFile = generatedFiles.find(f => f.path === 'package.json');
              let projName = 'omnigen-project';
              if (pkgFile) {
                  try { projName = JSON.parse(pkgFile.content).name; } catch(e){}
              }
              generatedFiles = setupProject(generatedFiles, projName);
          }

          if (isModification) {
            return mergeFiles(currentFiles, generatedFiles);
          }
          return generatedFiles;

      } catch (error) {
          console.error(`[AI] Attempt ${attempt} failed:`, error.message);
          lastError = error;
          // If it's a parsing error, we retry. If it's an API error (like quota), we might want to abort, but for now we retry all.
      }
  }

  throw new Error(`Failed to generate valid code after ${MAX_RETRIES} attempts. Last error: ${lastError?.message}`);
};

const runSimulation = async (files, command) => {
  const fileContext = files.map(f => `
    ./${f.path}:
    \`\`\`${f.path.split('.').pop()}
    ${f.content}
    \`\`\`
  `).join('\n');

  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash", 
    contents: `[VIRTUAL FS]\n${fileContext}\n\n[COMMAND]\n$ ${command}`,
    config: {
      systemInstruction: getExecutionSystemInstruction(),
      temperature: 0.1,
      maxOutputTokens: 2048,
    }
  });

  return response.text || "";
};

module.exports = { generateApp, runSimulation };
