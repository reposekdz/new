
import { GeneratedFile, AIModel, Attachment, ChatMessage, Platform, ProgrammingLanguage, ThinkingLevel } from "../types";

const API_BASE = 'http://localhost:3001/api';

export const generateAppCode = async (
  userPrompt: string, 
  model: AIModel, 
  attachments: Attachment[] = [],
  currentFiles: GeneratedFile[] = [],
  history: ChatMessage[] = [],
  platform: Platform = 'web',
  language: ProgrammingLanguage = 'typescript',
  thinkingLevel: ThinkingLevel = 'high'
): Promise<GeneratedFile[]> => {
  try {
    const response = await fetch(`${API_BASE}/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        prompt: userPrompt,
        model,
        attachments,
        currentFiles,
        history,
        platform,
        language,
        thinkingLevel
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Generation failed');
    }

    return await response.json();
  } catch (error: any) {
    console.error("API Error:", error);
    throw new Error(error.message || "Failed to connect to OmniGen backend");
  }
};

export const generateCommitMessage = async (
  stagedFiles: GeneratedFile[], 
  allFiles: GeneratedFile[]
): Promise<string> => {
    try {
        // We reuse the generate endpoint but with a specific prompt
        // The backend system instruction forces a JSON array of files. 
        // We ask the AI to wrap the commit message in a file named "COMMIT_MSG".
        const prompt = `Generate a Semantic Git Commit Message (Conventional Commits) for the following staged changes. Create a file named "COMMIT_MSG" containing the commit message as its content. Staged Files: ${stagedFiles.map(f => f.path).join(', ')}`;
        
        const response = await fetch(`${API_BASE}/generate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt,
                model: 'gemini-2.5-flash', // Fast model is fine for commits
                attachments: [],
                currentFiles: allFiles, // Context for better messages
                history: [],
                platform: 'web',
                language: 'typescript',
                thinkingLevel: 'low' // Fast
            })
        });

        if (!response.ok) return "chore: update files";
        const data = await response.json();
        
        const commitMsgFile = data.find((f: any) => f.path === 'COMMIT_MSG');
        if (commitMsgFile) return commitMsgFile.content.trim();
        
        // Fallback if no specific file found
        if (data.length > 0 && data[0].content) return data[0].content.trim();

        return "feat: updates to project structure"; 

    } catch (e) {
        return "wip: changes";
    }
};

export const runCodeSimulation = async (files: GeneratedFile[], command: string): Promise<string> => {
  try {
    const response = await fetch(`${API_BASE}/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ files, command })
    });

    if (!response.ok) throw new Error("Execution failed");
    return await response.text();
  } catch (error: any) {
    return `[CONNECTION ERROR]: ${error.message}. Ensure backend is running on port 3001.`;
  }
};

export const importGithubRepo = async (repoUrl: string): Promise<GeneratedFile[]> => {
    try {
        const response = await fetch(`${API_BASE}/import/github`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ repoUrl })
        });
        
        if (!response.ok) {
            const err = await response.json();
            throw new Error(err.error || "Failed to import GitHub repository");
        }
        return await response.json();
    } catch (error: any) {
        console.error("GitHub Import Error:", error);
        throw new Error(error.message || "Failed to import GitHub repository");
    }
};

export const setupProject = (projectName: string = 'omnigen-app', language: ProgrammingLanguage = 'typescript'): GeneratedFile[] => {
  const files: GeneratedFile[] = [];
  files.push({
    path: '.gitignore',
    content: `node_modules\n.DS_Store\ndist\nbuild\n.env\n.vscode/\n__pycache__/\nvenv/\ntarget/`
  });
  files.push({
    path: 'README.md',
    content: `# ${projectName}\n\nGenerated by OmniGen AI.\n\n## Language\n${language}`
  });
  return files;
};

export const getTemplateBoilerplate = (templateId: string): GeneratedFile[] => {
    const basicFiles = setupProject('omnigen-app', 'typescript');
    switch (templateId) {
        case 'react-vite':
            return [
                ...basicFiles, 
                { path: 'package.json', content: `{\n  "name": "vite-react",\n  "version": "0.0.0",\n  "scripts": {\n    "dev": "vite",\n    "build": "tsc && vite build"\n  },\n  "dependencies": {\n    "react": "^18.2.0",\n    "react-dom": "^18.2.0"\n  },\n  "devDependencies": {\n    "@vitejs/plugin-react": "^4.2.1",\n    "typescript": "^5.2.2",\n    "vite": "^5.2.0"\n  }\n}` },
                { path: 'index.html', content: `<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="UTF-8" />\n<title>Vite App</title>\n</head>\n<body>\n<div id="root"></div>\n<script type="module" src="/src/main.tsx"></script>\n</body>\n</html>`},
                { path: 'src/main.tsx', content: `import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.tsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n)` },
                { path: 'src/App.tsx', content: `import React from 'react';\n\nexport default function App() {\n  return (\n    <div className="min-h-screen bg-zinc-900 text-white flex items-center justify-center">\n      <h1 className="text-4xl font-bold">Hello OmniGen</h1>\n    </div>\n  );\n}` },
                { path: 'src/index.css', content: `@tailwind base;\n@tailwind components;\n@tailwind utilities;` }
            ];
        default: return basicFiles;
    }
};
